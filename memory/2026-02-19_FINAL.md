# 2026-02-19 记忆总结

## 一、OpenCTP 连接问题完整分析

### 问题背景
**用户目标**：在量化研究平台上使用 vn.py 连接 OpenCTP 模拟服务器，将真实数据集成到 FastAPI 后端，用于策略编写和回测

**核心矛盾**：
- Windows 上的 .vntrader 可以成功连接 OpenCTP
- Linux 上的 vn.py 无法连接 OpenCTP
- 配置信息完全一致
- 使用相同的账号、密码、服务器地址

### 关键发现

#### 1. 接口类型混淆（根本原因）

| 系统 | .vntrader | vn.py | OpenCTP 连接 |
|------|----------|------|-------------|
| Windows | ✅ 成功（TTS 接口） | N/A | ✅ 成功 |
| Linux | N/A | ❌ 失败（CTP 接口） | ✅ 可用 |

**证据**：
```
.vvntrader 日志显示：
2026-02-19 23:49:28.249 | INFO | TTS | 行情服务器连接成功
2026-02-19 23:49:28.251 | INFO | TTS | 交易服务器连接成功
2026-02-19 23:49:28.342 | INFO | TTS | 交易服务器登录成功
2026-02-19 23:49:28.343 | INFO | TTS | 结算信息确认成功
2026-02-19 23:49:28.343 | INFO | TTS | 行情服务器登录成功
```

**结论**：
- .vntrader 使用的是 **OpenCTP TTS 接口**
- vn.py 使用的是 **标准 CTP 接口**
- **接口不同，所以连接失败**

#### 2. 版本信息

| 组件 | 版本 |
|------|------|
| vn.py | 4.3.0 |
| vn.py_ctp | 6.7.11.2 |
| TTS 动态库 | 6.7.11 |
| OpenCTP TTS | 6.7.11 |

#### 3. 配置信息

| 配置项 | 值 |
|-------|-----|
| 账号 | 17130 |
| 密码 | 123456（已重置） |
| 经纪商 | 9999 |
| 交易服务器 | tcp://trading.openctp.cn:30001 |
| 行情服务器 | tcp://trading.openctp.cn:30011 |
| 产品名称 | (空) |
| 授权编码 | (空) |

**配置状态**：✅ 完全正确

### 尝试的解决方案

#### 方案 1：替换为 OpenCTP TTS 动态库
**执行**：
- 下载了 OpenCTP 官方 TTS-CTPAPI 6.7.11
- 替换了 vn.py_ctp 中的动态库
- 备份了原有动态库

**结果**：❌ 仍然失败
- 未收到任何事件或日志
- 会话仍然断开（错误 4097）

#### 方案 2：升级 vn.py
**问题**：
- vn.py 通过系统包管理器安装（externally-managed-environment）
- 无法直接使用 pip upgrade
- 当前版本：4.3.0（可能较旧）

**结果**：未执行（系统限制）

#### 方案 3：使用 VeighNa Station CLI 模式
**发现**：
- VeighNa 源码已存在：`/root/.openclaw/workspace/vnpy/`
- 包含 VeighNa Station（GUI + CLI 版本）
- 主入口：`/root/.openclaw/workspace/vnpy/examples/veighna_trader/run.py`

**问题**：
- 缺少依赖模块：vnpy_ctastrategy, vnpy_ctabacktesting, vnpy_portfolio, vnpy_spreadbacktesting
- 系统包管理器限制

**结果**：未执行（依赖缺失）

### 最终决策

#### 方案选择
**采用方案：继续使用模拟数据（当前方案）**

**理由**：
1. ✅ 系统已完全稳定运行
2. ✅ VeighNa Web 界面正常运行（真实数据）
3. ✅ FastAPI 后端正常运行（模拟数据）
4. ✅ 所有功能可开发和测试
5. ✅ 不阻塞任何工作
6. ✅ 无风险

**后续优化**：
- 当有时间时，研究 VeighNa Station CLI 模式
- 或等待 OpenCTP 官方的 vn.py 版本
- 或寻找 OpenCTP 专用的 Python 库

---

## 二、多代理系统 v3.0 完整优化

### 优化依据
基于 @gkxspace 的文章《5 角色 AI 协作操作系统》

### 核心改进

#### 1. 双轨治理机制

**配置轨（平台级控制）**：
- channel policy：groupPolicy、dmPolicy - 控制群聊和私聊的基本策略
- requireMention：谁默认必须被 @ 才响应
- bindings：消息路由映射（channel + accountId -> agentId）
- dmScope：会话隔离粒度（per-account-channel-peer）
- agentToAgent ping-pong 限制：设为 0，压制 agent 之间的无意义对话

**规则轨（行为级控制）**：
- SOUL.md：角色的灵魂文件——人格定义、行为模式、质量底线
- AGENTS.md：运行手册——协作流程、记忆规范、检查清单
- ROLE-COLLAB-RULES.md：角色专属的协作边界和红线
- TEAM-RULEBOOK.md：团队统一的协作硬规则（所有角色共享）
- IDENTITY.md：身份定义——名字、定位、能力范围、对外口径
- USER.md：用户画像——偏好、目标、禁忌、常用术语
- TOOLS.md：工具清单——允许调用哪些工具、权限边界

**两条轨道叠加效果**：
- 平台层先限流 + 行为层再约束
- 不是把一切压在模型的"自觉"上
- 模型会犯错、会漂移、会忘记规则
- 必须在配置层先做硬约束，再在提示词层做软引导
- **双保险**

#### 2. 私聊模式 vs 群聊模式

**私聊模式**：
- 定位：各角色作为单兵专家
- 行为：端到端处理用户问题
- 不需要协作流程，直接给出完整答案
- 质量标准是"一个人能搞定"

**群聊模式**：
- 定位：按团队协作协议做增量接力
- 每个角色只负责自己擅长的部分
- 总指挥负责串联和收口

**总指挥（群聊模式）**：
- 默认沉默观察，监听全局态势
- 判断是否需要协作
- 做任务拆解和派工
- 必要时才强介入，避免抢话

**其他角色（群聊模式）**：
- 只在被明确 @ 时才行动
- 减少噪音，避免抢话
- 按团队协作协议做增量接力

**同一角色不同场景表现差异化**：
- 不是靠模型自己判断
- 是靠规则文件明确告诉它

#### 3. 标准化文件体系

**每个 Agent 的标准文件结构**：
```
agents/{agent_name}/
├── SOUL.md                    # 角色灵魂
├── AGENTS.md                  # 运行手册
├── IDENTITY.md                # 身份定义
├── ROLE-COLLAB-RULES.md       # 协作边界
├── MEMORY.md                  # 长期记忆
├── GROUP_MEMORY.md            # 群聊记忆
├── HEARTBEAT.md              # 心跳规范
└── memory/
    └── YYYY-MM-DD*.md        # 每日流水
```

#### 4. 分层记忆系统

**记忆分层策略**：

1. **短期流水（daily memory）**
   - 记录当天的任务过程、上下文碎片、现场决策
   - 文件名按日期命名，天然有时间线
   - 位置：`memory/YYYY-MM-DD*.md`

2. **长期记忆（MEMORY.md）**
   - 沉淀稳定的偏好、长期决策、可复用经验、硬规则
   - 不是什么都往里塞，只有经过验证的、稳定的信息才写入
   - 位置：`agents/{agent_name}/MEMORY.md`

3. **群聊长期记忆（GROUP_MEMORY.md）**
   - 只保留群里可复用且安全的信息
   - 不混入私聊内容，这是隐私红线
   - 位置：`agents/{agent_name}/GROUP_MEMORY.md`

4. **冷归档（archive）**
   - 旧数据定期归档，防止活跃上下文膨胀失控
   - 不是删除，是移到低优先级存储
   - 位置：`memory/archive/`

5. **检索机制（memory_search + memory_get）**
   - 先语义召回，再精确读取
   - 避免全量加载——上下文窗口是有限资源

**分层核心价值**：
- 私聊质量不被群聊历史污染
- 群聊协作不被个人私密上下文干扰
- 上下文窗口"按需加载"，不是"全量灌入"

### 代理角色（决策层 + 工程师池）

#### 决策层（3人）

1. **总指挥 - zongzhihui**
   - 标签：@zongzhihui
   - 职责：全局协调、任务分解、动态派工、进度监控、纠偏优化、收口验收
   - 私聊模式：单兵专家，端到端处理
   - 群聊模式：默认沉默观察，必要时强介入

2. **军师 - junshi**
   - 标签：@junshi
   - 职责：需求分析、架构设计、技术选型、风险评估、策略分析
   - 私聊模式：独立分析，给出专业建议
   - 群聊模式：技术决策层，@ 时响应

3. **智库 - zhiku**
   - 标签：@zhiku
   - 职责：代码审查、质量审核、合规检查、最佳实践
   - 私聊模式：质量审核
   - 群聊模式：交付前审核，@ 时响应

#### 工程师池（9人）

1. **架构师 - architect**
   - 标签：@architect
   - 职责：架构设计、技术选型、模块划分、接口设计、扩展性考虑

2. **Coder**
   - 标签：@coder
   - 职责：代码开发、功能实现、代码规范、单元测试、代码注释

3. **Researcher**
   - 标签：@researcher
   - 职责：策略调研、资料搜集、原理分析、竞品分析、资料整理

4. **Tester**
   - 标签：@tester
   - 职责：单元测试、功能测试、性能测试、集成测试、测试报告

5. **Reviewer**
   - 标签：@reviewer
   - 职责：代码审查、最佳实践、潜在问题、改进建议、安全检查

6. **Analyst**
   - 标签：@analyst
   - 职责：策略分析、风险评估、性能分析、数据分析、优化建议

7. **Data**
   - 标签：@data
   - 职责：数据获取、数据清洗、数据转换、数据处理、数据存储

8. **Writer**
   - 标签：@writer
   - 职责：需求文档、技术文档、用户手册、项目文档、知识沉淀

### 软件工程流程（8 阶段）

1. **需求分析** → 军师 + 总指挥
   - 编写任务需求书（PRD）
   - 明确功能目标、非功能需求、用户场景、验收标准

2. **架构设计** → 军师 + architect（复杂任务）
   - 设计系统架构
   - 规划模块划分
   - 定义模块边界和职责
   - 设计接口规范

3. **实现规划** → 军师 + 总指挥
   - 实现路径规划
   - 技术风险评估
   - 时间预估

4. **任务分解** → 总指挥
   - 拆分为可执行子任务
   - 分配给工程师
   - 定义依赖关系

5. **开发执行** → 各类工程师
   - 按照设计实现功能
   - 编写单元测试
   - 代码符合规范

6. **质量保证** → tester + reviewer + 智库
   - 代码审查
   - 功能测试
   - 性能测试
   - 质量检查

7. **迭代优化** → 总指挥 + 军师 + 工程师
   - 反馈收集
   - 问题修复
   - 功能完善

8. **验收交付** → 智库 + 总指挥
   - 最终质量审核
   - 合规检查
   - 交付用户

### 弹性工程师调度机制

#### 动态调整场景

| 场景 | 触发条件 | 调整方案 |
|------|---------|---------|
| 进度落后 | 任务执行进度落后于计划 | 增派工程师分担任务 |
| 技术难题 | 遇到当前工程师无法解决的技术难题 | 增派专家工程师 |
| 提前完成 | 任务提前完成或有富余资源 | 调整工程师到其他任务 |
| 需求变更 | 用户提出新需求，需求范围扩大 | 重新规划，增派或调整工程师 |

#### 动态派工逻辑

```
用户任务
    ↓
【任务分析】→ 判断复杂度
    ↓
【动态组队】→ 决定需要哪些工程师
    ├── 简单任务 (单一技能) → 1个工程师
    ├── 中等任务 (多模块) → 2-3个工程师
    ├── 复杂任务 (多领域) → 4+工程师 + 军师 + 智库
    └── 超复杂任务 → 组建专项团队
    ↓
【任务分解】→ 分解为可执行子任务
    ↓
【分派执行】→ 按需调用工程师
    ↓
【动态调整】→ 执行过程中增减工程师
    ├── 进度落后 → 增派工程师
    ├── 技术难题 → 增派专家
    ├── 提前完成 → 调整资源
    └── 需求变更 → 重新规划
    ↓
【质量保证】→ 代码审查 + 测试 + 智库审核
    ↓
【迭代优化】→ 反馈收集 + 问题修复
    ↓
【验收交付】→ 智库审核 + 总指挥验收 → 交付用户
```

---

## 三、系统状态总结

### VeighNa Web 界面
- **状态**：✅ 正常运行
- **地址**：http://154.219.126.12:8080
- **数据源**：真实数据（通过 .vntrader 连接 OpenCTP TTS）
- **功能**：完整交易功能

### FastAPI 后端
- **状态**：✅ 正常运行
- **数据源**：模拟数据
- **功能**：完整 API 功能

### 多代理系统
- **状态**：✅ 已优化到 v3.0
- **版本**：v3.0
- **架构**：Single Gateway + Multi-Agent + Multi-Workspace + Multi-Channel
- **角色数**：12（3 决策层 + 9 工程师池）

### OpenCTP 连接
- **状态**：⏳ 待解决
- **问题根源**：vn.py_ctp 与 OpenCTP TTS 兼容性问题
- **当前方案**：继续使用模拟数据
- **备用方案**：
  1. 使用 VeighNa Station CLI 模式（Linux）
  2. 等待 OpenCTP 官方的 vn.py 版本
  3. 寻找 OpenCTP 专用的 Python 库

### 系统稳定性
- **状态**：✅ 完全稳定
- **可用功能**：所有功能可用
- **依赖**：无外部依赖（模拟数据）

---

## 四、关键决策记录

### 决策 1：OpenCTP 连接策略
- **时间**：2026-02-19 16:50 UTC
- **决策**：继续使用模拟数据
- **原因**：
  - vn.py 连接失败（TTS 接口兼容性问题）
  - 系统已完全稳定运行
  - 不阻塞任何开发和测试工作
  - 风险最低，可靠性最高

### 决策 2：多代理系统优化
- **时间**：2026-02-19 15:30 UTC
- **决策**：优化到 v3.0
- **原因**：
  - 基于 @gkxspace 的文章
  - 实现完整的软件工程流程
  - 支持弹性工程师调度
  - 支持私聊 vs 群聊模式
  - 实现双轨治理机制

### 决策 3：任务执行模式
- **时间**：2026-02-19 16:22 UTC
- **决策**：自主决策，自主行动
- **原因**：
  - 用户要求"尽量自行决策，自主行动"
  - 从目标出发，分析对比解决问题的不同路径和策略
  - 网上多渠道搜索相关资料
  - 必要时候团队一起行动
  - 一起开会头脑风暴，优选最终实现策略
  - 大不了重新退回去重来

---

## 五、技术文档位置

### OpenCTP 连接分析报告
1. **vn.py 使用经验报告**：`/root/.openclaw/workspace/vnpy_opencpt_研究报告.md`
2. **vn.py 版本分析报告**：`/root/.openclaw/workspace/quant-factory/vnpy_version_analysis_report.md`
3. **最终解决方案报告**：`/root/.openclaw/workspace/vnpy_trading/FINAL_SOLUTION_REPORT.md`
4. **任务分解与执行策略**：`/root/.openclaw/workspace/quant-factory/TASK_DECOMPOSITION_AND_EXECUTION_STRATEGY.md`

### 多代理系统文档
1. **详细实现方案**：`/root/量化研究平台_多代理系统_详细实现方案_v2.0.md`
2. **AGENTS.md**：`/root/.openclaw/workspace/quant-factory/AGENTS.md`
3. **SOUL.md**（总指挥）：`/root/.openclaw/workspace/quant-factory/agents/zongzhihui/SOUL.md`
4. **SOUL.md**（军师）：`/root/.openclaw/workspace/quant-factory/agents/junshi/SOUL.md`
5. **团队规则**：`/root/.openclaw/workspace/quant-factory/shared/TEAM-RULEBOOK.md`
6. **系统优化报告**：`/root/.openclaw/workspace/quant-factory/SYSTEM_OPTIMIZATION_v3.0.md`

---

## 六、长期记忆更新

### OpenCTP 连接配置
- **账号**：17130
- **密码**：123456
- **服务器**：
  - 交易：tcp://trading.openctp.cn:30001
  - 行情：tcp://trading.openctp.cn:30011
- **接口类型**：OpenCTP TTS（不是标准 CTP）
- **状态**：待解决（建议使用模拟数据）

### 多代理系统状态
- **版本**：v3.0
- **架构**：Single Gateway + Multi-Agent + Multi-Workspace + Multi-Channel
- **模式**：双轨治理（配置层 + 规则层）
- **文件体系**：标准化，每个角色独立 workspace
- **运行模式**：私聊 vs 群聊区分

### vn.py 版本状态
- **核心版本**：4.3.0（通过系统包管理器安装）
- **vn.py_ctp**：6.7.11.2
- **TTS 动态库**：6.7.11（OpenCTP 官方）
- **兼容性问题**：vn.py_ctp 使用标准 CTP 接口，OpenCTP 使用 TTS 接口

---

## 七、下一步计划

### 短期（立即可用）
- ✅ 继续使用模拟数据
- ✅ 使用 VeighNa Web 界面进行真实交易
- ✅ 使用 FastAPI 后端进行策略开发和测试
- ✅ 使用多代理系统进行团队协作

### 中期（可选优化）
- 📝 研究 VeighNa Station CLI 模式
- 📝 寻找 OpenCTP 官方的 vn.py 版本
- 📝 开发 OpenCTP 专用的 Python 库
- 📝 完善 OpenCTP 连接文档

### 长期（可选开发）
- 🔄 实现 @zongzhihui 路由器（需要修改 OpenCLAW Gateway）
- 🔄 完善 sessions_spawn 并行执行
- 🔄 集成 vn.py 真实数据到 FastAPI

---

**生成时间**：2026-02-19 16:59 UTC
**保存位置**：`memory/2026-02-19.md`
